import * as React from "react";
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export declare type EventKeys = "onMount" | "onUpdate" | "onUnmount" | "initialState";
export declare type StateUpdater<S> = (state: Readonly<S>) => Partial<S>;
export declare type StateCallback = () => void;
export declare type SetState<S> = (updaterOrState: StateUpdater<S> | Partial<S>, callback?: () => void) => void;
export declare type SetStateWithType<S, K> = (updaterOrState: StateUpdater<S> | Partial<S>, callback: StateCallback | undefined, type: K) => void;
export declare type SetContextState<S, K> = (context: string, updaterOrState: StateUpdater<S> | Partial<S>, callback?: StateCallback, type?: K) => void;
export declare type Action<S, T> = T extends (...args: infer U) => any ? (...args: U) => StateUpdater<S> : (...args: unknown[]) => StateUpdater<S>;
export declare type Selector<S, T> = T extends (...args: infer U) => infer R ? (...args: U) => (state: Readonly<S>) => R : (...args: unknown[]) => (state: Readonly<S>) => any;
export interface EffectProps<S> {
    state: Readonly<S>;
    setState: SetState<S>;
}
export declare type Effect<S, T> = T extends (...args: infer U) => infer R ? (...args: U) => (props: EffectProps<S>) => R : (...args: unknown[]) => (props: EffectProps<S>) => any;
export declare type ActionMap<S, P> = {
    [K in keyof P]: Action<S, P[K]>;
};
export declare type SelectorMap<S, P> = {
    [K in keyof P]: Selector<S, P[K]>;
};
export declare type EffectMap<S, P> = {
    [K in keyof P]: Effect<S, P[K]>;
};
export interface OnMountProps<S> extends EffectProps<S> {
}
export interface OnMount<S> {
    (props: OnMountProps<S>): any;
}
export interface OnUpdateProps<S, AP = {}, EP = {}> extends EffectProps<S> {
    prevState: Readonly<S>;
    type: keyof AP | keyof EP | EventKeys;
}
export interface OnUpdate<S, AP = {}, EP = {}> {
    (props: OnUpdateProps<S, AP, EP>): any;
}
export interface OnUnmountProps<S> extends EffectProps<S> {
}
export interface OnUnmount<S> {
    (props: OnUnmountProps<S>): any;
}
export interface ShouldUpdateProps<S> {
    state: Readonly<S>;
    nextState: Readonly<S>;
}
export interface ShouldUpdate<S> {
    (props: ShouldUpdateProps<S>): boolean;
}
export interface ProviderOnMountProps<S> {
    state: S;
    setContextState: SetContextState<S[keyof S], string>;
}
export interface ProviderOnMount<S> {
    (props: ProviderOnMountProps<S>): any;
}
export interface ProviderOnUpdateProps<S> {
    prevState: S;
    state: S;
    setContextState: SetContextState<S[keyof S], string>;
    context: string;
    type?: string;
}
export interface ProviderOnUpdate<S> {
    (props: ProviderOnUpdateProps<S>): any;
}
export interface ProviderOnUnmountProps<S> {
    state: S;
}
export interface ProviderOnUnmount<S> {
    (props: ProviderOnUnmountProps<S>): any;
}
export declare type MountContainer = (context: string, onMount?: () => void) => (onUnmount?: () => void) => void;
export interface ContainerProps<S, AP = {}, SP = {}, EP = {}> {
    initialState?: Partial<S>;
    context?: string;
    actions?: ActionMap<S, AP>;
    selectors?: SelectorMap<S, SP>;
    effects?: EffectMap<S, EP>;
    onMount?: OnMount<S>;
    onUpdate?: OnUpdate<S, AP, EP>;
    onUnmount?: OnUnmount<S>;
    shouldUpdate?: ShouldUpdate<S>;
    pure?: boolean;
    children: (props: S & AP & SP & EP) => React.ReactNode;
}
export interface InnerContainerProps<S, AP = {}, SP = {}, EP = {}> extends ContainerProps<S, AP, SP, EP> {
    state?: S;
    setContextState?: SetContextState<S, keyof AP | keyof EP | EventKeys>;
    mountContainer?: MountContainer;
}
export declare type ComposableContainerProps<S, AP = {}, SP = {}, EP = {}> = Omit<ContainerProps<S, AP, SP, EP>, "actions" | "selectors" | "effects">;
export interface ComposableContainer<S, AP = {}, SP = {}, EP = {}> {
    (props: ComposableContainerProps<S, AP, SP, EP>): JSX.Element;
}
export interface ProviderProps<S> {
    initialState?: Partial<S>;
    devtools?: boolean;
    onMount?: ProviderOnMount<S>;
    onUpdate?: ProviderOnUpdate<S>;
    onUnmount?: ProviderOnUnmount<S>;
}
